# -*- coding: utf-8 -*-
"""
Created on Mon Mar 14 08:17:51 2022
    Spectrum data processing. DataProcessing object will contain data and
    methods to use for processing and visualization.
    Plots usually take either a wavelength of interest, a time of interest, and/or 
    factor types as parameters.
    example (with module in path):
        import SpectralDataProcessing as spd
        dp = spd.DataProcessing()
        dp.readIn(filepath.csv)
        dp.dropData()
        dp.linearFit()
        dp.plot_this()
        dp.plot_that(wavelength=777.455)
        ...
        
@author: lridings
"""
#%% Imports
import pandas as pd
import numpy as np
from sklearn import linear_model
from matplotlib import pyplot as plt
from scipy import signal
import bisect
#%% Class stuff
class DataProcessing:
    def __init__(self):
        """
        Constructor for DataProcessing class. Initializes everything as blank.
        Class attributes:
            df - dataframe of raw data taken from the csv generated by OceanView Data Script.py
            sOnData - dataframe with only the data with a lit plasma and real pressure data
            dataPath - path to the csv data file
            date - list of the datetimes of collected spectra
            regs - list of the linear regression objects for each wavelength point
            scores - list of the coefficients of determination of the linear regressions
        """
        self.df=pd.DataFrame()
        self.sOnData=pd.DataFrame()
        self.dataPath = ''
        self.date = []
        self.regs = []
        self.scores=[]
        if not __name__== '__main__':
            plt.close('all')
            
    def setPath(self,path=r"C:\Users\lridings\Documents\Python Scripts\notebook_mats\test_data.csv"):
        """
        Set path to data file. Defaults to condition testing data.
        """
        self.dataPath=path
#%% Data preprocessing and wrangling
    def readIn(self,dataFile = ''):
        """
        Method to read in data from csv. csv indexed by datetime, with source pressure
        column, solenoid current column, and a column for each pixel on the spectrometer
        Sets the df attribute after reading data in.
        Sets the date attribute based on datetime indices.
        """
        if dataFile: self.setPath(dataFile)
        else: self.setPath()
        data = pd.read_csv(self.dataPath,index_col=0)
        wavelengths = [float(i) for i in data.columns[3:]]
        ind = pd.to_datetime(data.index,format='%Y-%m-%d %H:%M:%S')
        data.index = ind
        data.columns = data.columns[:3].values.tolist()+wavelengths
        self.df = data
        self.date = data.index
        self.wavs = np.asarray(wavelengths)
    def dropData(self, intensityThreshold = 100, wavelength = 777.455):
        """
        Drop rows where the plasma is obviously not lit. Line at 777 is the 
        absolute strongest line of emission for a lit oxygen plasma. If this line isn't
        above a threshold, the source should be considered unlit.
        """
        temp = self.df[self.df[wavelength]>intensityThreshold]
        temp = temp[temp['Source Pressure (mBar)']>0]
        self.sOnData = temp
        
#%% General 'get' funcs. Use to pick out time indices, t, given a condition, or a spectrum sample at time t
    def getSpectrum(self,t):
        """Return the spectrum taken at time 't'. 't' must be exact."""
        ind = self.sOnData.index.tolist().index(np.datetime64(t))
        return np.asarray(self.sOnData.iloc[ind,3:])

    def getPeakIntensity(self,wavelength=486.473,clean=True):
        """Return the datetime which has the highest value for the given wavelength. If wavelength of interest isn't exact,
            will return as closest pixel wavelength."""
        try:
            if clean: return self.sOnData[self.sOnData[wavelength]==self.sOnData[wavelength].max()].index.values[0]
            else: return self.df[self.df[wavelength]==self.df[wavelength].max()].index.values[0]
        except Exception as e:
            print('Entered inexact wavelength. Finding closest match.')
            wv_id = bisect.bisect_left(self.sOnData.columns[3:],wavelength)
            return self.getPeakIntensity(self.sOnData.columns[3:][wv_id],clean)
#%% Statistical Processing
    def linearFit(self,factors=['Source Pressure (mBar)', 'Solenoid Current (A)','RF Power Forward (W)'], clean=True):
        """
        Run a linear regression for each wavelength point using the pressure and solenoid current
            as the factors, and the measured intensity as the response.
        Keyword arguments:
            clean -- use the cleaned data, sOnData, if 'True'. Use the raw data if arg is false.
                default -> True
        Assign reg models to 'regs' and coefs of determination to 'scores'
        """
        if self.df.empty:
            print('Make sure to get data read in!')
            return
        data = self.df
        if clean and not self.sOnData.empty: data = self.sOnData
        X = data[factors]
        regs = []
        scores = []
        for wav in data.columns[3:]:
            reg = linear_model.LinearRegression()
            reg.fit(X,data[wav])
            score = reg.score(X,data[wav])
            regs.append(reg)
            scores.append(score)
        self.regs = regs
        self.scores=scores

    def plotModelFits(self,cutoff=0.0):
        """
        Create a plot which displays the model R^2 vs. the wavelengths.
        Keyword arguments:
            cutoff -- Minimum R^2 value to plot
        """
        ind = []
        for i in range(len(self.scores)):
            if self.scores[i]>cutoff:
                ind.append(i)
        wavs = self.wavs
        fig1 = plt.figure()
        plt.title(label='Linear Fit R^2 vs Wavelength')
        y = [self.scores[i] for i in ind]
        plt.scatter([wavs[i] for i in ind],y,c=y,cmap='RdYlGn')
        plt.xlabel('Wavelength (nm)')
        plt.ylabel('R^2')
        return fig1
#%% I vs. Effect Plotting
    def plot_two_factors(self,wavelength=616.08,factor1='Source Pressure (mBar)',factor2='RF Power Forward (W)'):
        """
        Intensity vs. factor one on graph, with factor2 as color schema

        Parameters
        ----------
        wavelength : int, optional
            DESCRIPTION. The default is 616.08, O I emission line
        factor1 : str, optional
            DESCRIPTION. The default is 'Source Pressure (mBar)'.
        factor2 : str, optional
            DESCRIPTION. The default is 'RF Power Forward (W)'.

        Returns
        -------
        fig : matplotlib.pyplot.Figure
            Returns figure for saving, etc.

        """
        fig,ax=plt.subplots()
        ax.set_title(factor1 + ' & '+factor2 + '\n vs. Intensity of ' +str(wavelength)+'nm')
        scatter=ax.scatter(self.sOnData[factor1],self.sOnData[wavelength],
                           c=self.sOnData[factor2],cmap='plasma')
        ax.set_xlabel(factor1)
        ax.set_ylabel('Measured Intensity (counts)')
        fig.colorbar(scatter,ax=ax,label=factor2)
        return fig
    
    def plotPressureVsIntensity(self,wavelength=822.292,factor='Solenoid Current (A)'):
        """
        Create a plot which shows the relationship between pressure and intensity
            for a given wavelength. 
        Keyword arguments:
            wavelength -- wavelength at which to plot the pressure vs. intensity data
        Uses the solenoid current as a color map for each plotted point.
        """
        y = self.sOnData[self.sOnData['Source Pressure (mBar)']>1e-7]
        fig,ax = plt.subplots()
        # wavelength=308.395
        ax.set_title(label='Wavelength: ' + str(wavelength))
        scatter = ax.scatter(y['Source Pressure (mBar)'],y[wavelength],c=y[factor])
        ax.set_xlabel('Source Pressure (mBar)')
        ax.set_ylabel('Measured Intensity (counts)')
        plt.colorbar(scatter,label=factor)
        return fig
    
    def solenoideffectPlots(self,numplots=5,scorethresh=0.5):
        """
        Plot intensity vs. pressure for the wavelengths most correlated to solenoid current.
        Keyword arguments:
            numplots -- number of plots for strongest effect between sol current and intensity
                default -> 5 plots
            scorethresh -- minimum R^2 value to consider when plotting
                default -> R^2 of 0.5 or higher included
        """
        scoreIndex = []
        for score in self.scores:
            if score>scorethresh:
                scoreIndex.append(self.scores.index(score))
        topregs = []
        for i in scoreIndex:
            topregs.append(self.regs[i].coef_[1])
        sortregs = topregs.copy()
        sortregs.sort(reverse=True)
        figs = []
        for maxsol in sortregs[:numplots]:
            top = topregs.index(maxsol)
            print(self.sOnData.columns[scoreIndex[top]])
            print(self.scores[scoreIndex[top]])
            figs.append(self.plotPressureVsIntensity(self.sOnData.columns[scoreIndex[top]]))
        return figs
#%% Intensity vs. Time Plots
    def plotIntensityVsTime(self,wavelength=486.473):
        """
        *COLORMAP SCATTERPLOT
        
        Create a plot of intensity as a function of time for a given wavelength.
        Keyword arguments:
            wavelength -- wavelength at which to plot time vs. intensity
                default -> Nitrogen III line
        Uses the source pressure as a color map for each plotted point.
        """
        y = self.sOnData
        fig,ax = plt.subplots()
        ax.set_title(label='Wavelength: '+str(wavelength))
        x = y.index
        scatter = ax.scatter(x,y[wavelength],c=y['Source Pressure (mBar)'],cmap='magma')
        ax.set_xlabel('Time')
        ax.set_ylabel('Measured Intensity (counts)')
        fig.colorbar(scatter,label='Source Pressure (mBar)')
        # ax.set_xticklabels(ax.get_xticklabels(),rotation=45)
        return fig
    
    def IvsT_factor(self,wavelength=844.594,factor='Source Pressure (mBar)'):
        """
        * DUAL AXIS LINE PLOT
        More like the test stand graphics, visually exaggerates noise
        Parameters
        ----------
        wavelength : int, optional
            DESCRIPTION. The default is 844.594.
        factor : str, optional
            DESCRIPTION. The default is 'Source Pressure (mBar)'.

        Returns
        -------
        fig : matplotlib.pyplot.Figure
            DESCRIPTION.

        """
        
        y=self.sOnData
        fig,ax=plt.subplots()
        ax.set_title(label='Wavelength: '+str(wavelength))
        x=y.index
        scatter = ax.plot(x,y[wavelength],c='green')
        ax.set_ylabel('Intensity')
        ax.yaxis.label.set_color('green')
        ax.set_xlabel('Time')
        # ax.set_xticklabels(ax.get_xticklabels(),rotation=45)
        ax2=ax.twinx()
        ax2.plot(x,y[factor],c='red')
        ax2.set_ylabel(factor)
        ax2.yaxis.label.set_color('red')
        ax.grid(which='both')
        fig.tight_layout()
        return fig
    
#%% Intensity vs. Wavelength Plotting
    def plotSpectrum(self,place,ylim = 5000,color='blue',clean = True):
        """
        Plot the spectrum at either some time t. Choose the time to plot through 
            a datetime or an int. Add the pressure data to the title
        Keyword arguments:
            place -- 
                Pass an int to select the index of the clean data directly,
                    and the timestamp will be automatically found from the data table
                Pass a datetime to select the date directly.
            ylim -- Set the max count displayed on the plot
        """
        dat = self.sOnData
        if not clean: dat = self.df
        fig, ax = plt.subplots()
        if isinstance(place, int):
            ind = place
            t = dat.index[ind]
            ax.set_title(label=str(dat[['Source Pressure (mBar)','Solenoid Current (A)']].iloc[ind]).split(',')[0])
            ax.plot(dat.columns[3:],dat.iloc[ind,3:],color=color)
            plt.ylim([0,ylim])
            return fig
        else:
            t = place
            ind = dat.index.tolist().index(np.datetime64(t)) #weirdness with pandas and numpy datetime objects
            plt.title(label=str(dat[['Source Pressure (mBar)','Solenoid Current (A)']].iloc[ind]).split(',')[0])
            plt.plot(dat.columns[3:],dat.iloc[ind,3:],color=color)
            plt.ylim([0,ylim])
            return fig
        
    def plotSpectrumOnAxis(self,ax,t,ylim = 1500,color='blue',alpha=1.0,line='solid'):
        """
        Plot the spectrum at some time t. Choose the time to plot through 
            a datetime. Add the pressure data to the title
        Keyword arguments:
            ax -- which axis object to draw the spectrum to
            place -- 
                Pass a datetime to select the spectrum.
            ylim -- Set the max count displayed on the plot
        """
        ind = self.sOnData.index.tolist().index(np.datetime64(t)) #weirdness with pandas and numpy datetime objects
        title = ax.get_title()+'\n'+str(self.sOnData[['Source Pressure (mBar)','Solenoid Current (A)']].iloc[ind]).split(',')[0]
        ax.set_title(label=title)
        line = ax.plot(self.wavs,self.sOnData.iloc[ind,3:],color=color,linestyle=line,alpha=alpha)
        ax.set_ylim([0,ylim])
        ax.set_xlim([300,1000])
        return line[0]
    
    def overlaySpectra(self,ts,ionvneut=True,ylim=1500):
        """
        Plot two spectra over each other. Defaults to the plot of two spectra,
        one of which is at peak ion emission and one is peak neutral emission
        Params:
            t1 -- time index of the first spectrum
            t2 -- time index of the second spectrum
            ionvneut -- whether or not this is comparing ions/neutrals or arbitrary spectra
            ylim -- upper y limit of the plot
        """
        
        fig, ax1 = plt.subplots()
        i = 0
        for t in ts:
            line = self.plotSpectrumOnAxis(ax1,t,ylim=ylim)
            # line2 = self.plotSpectrumOnAxis(ax1,t2,color='red',line='dotted',ylim=ylim)
            if ionvneut:
                if i==0:
                    line.set_label('Peaked Ion Intensity')
                else:
                    line.set_label('Peaked Neutral Intensity')
                    line.set_linestyle('dotted')
                    line.set_color('red')
            else:
                line.set_label(str(t))
            ax1.legend(loc='upper left')
            i=+1
        return fig
        
    def plotReference(self):
        """Make and return a plot of the reference spectrum used in the data."""
        fig = self.plotSpectrum(place=self.df.index[-1],ylim=1000,clean=False)
        return fig
#%% Linear Fit functions and plots.
    def getPressureCoefs(self,squeeze=True):
        """Get the partial(intensity)/partial(pressure)'s for the linear fits"""
        coefs = []
        for reg in self.regs:
            coefs.append(reg.coef_[0])
        if squeeze: return [coefs[i]*self.scores[i]**6 for i in range(len(coefs))]
        return np.asarray(coefs)
    
    def getSolenoidCoefs(self,squeeze=True):
        """Get the partial(intensity)/partial(solenoid current)'s for the linear fits"""
        coefs = []
        for reg in self.regs:
            coefs.append(reg.coef_[1])
        if squeeze: return [coefs[i]*self.scores[i]**6 for i in range(len(coefs))]
        return np.asarray(coefs)
    
    def getPowerCoefs(self,squeeze=True):
        """return foward power linear slope coefs"""
        coefs = []
        for reg in self.regs:
            coefs.append(reg.coef_[2])
        if squeeze: return [coefs[i]*self.scores[i]**6 for i in range(len(coefs))] # squeeze by squishing with (R^2)^6
        return np.asarray(coefs)
    
    def getCoefs(self,factor):
        if factor=='pressure': return self.getPressureCoefs()
        elif factor=='solenoid': return self.getSolenoidCoefs()
        elif factor=='power': return self.getPowerCoefs()
    def plotCoefs(self, coefs):
        """Plot something (linear fit coefficients) against the wavelengths"""
        fig, ax = plt.subplots()
        line = ax.plot(self.wavs,coefs)
        return fig,ax
    def plotCoefsSqueeze(self, coefs):
        """Plot coefficients and 'squeeze' out the best determined ones by reducing
        with the coefficient of the determination which is on domain (0,1)"""
        fig, ax = plt.subplots()
        line = ax.plot(self.wavs,[coefs[i]*self.scores[i]**6 for i in range(len(coefs))])
        return fig,ax
    
    def plotPressureCoefs(self,smooth=True):
        fig,ax = self.plotCoefsSqueeze(self.getPressureCoefs(smooth))
        ax.set_title('Pressure fit coefficients per wavelength')
        ax.set_ylim([-1e8,1e8])
        return fig
    
    def plotSolenoidCoefs(self,smooth=True):
        """Plot the solenoid coefs against wavelength. If smooth, use squeeze plot"""
        fig,ax = self.plotCoefsSqueeze(self.getSolenoidCoefs(smooth))
        ax.set_title('Solenoid fit coefficients per wavelength')
        return fig
    
    def plotPowerCoefs(self,smooth=True):
        fig,ax = self.plotCoefsSqueeze(self.getPowerCoefs(smooth))
        ax.set_title('Power fit coefficients per wavelength')
        return fig
#%% Signal Processing and Peak Finding funcs and plots
    
    def getCoefPeaks(self,factor,height=1e6,distance=16):
        """Get the wavelengths where the factor has peak effect on intensity"""
        coefs = self.getCoefs(factor)
        peakInd = signal.find_peaks(abs(coefs),height=height,distance=distance)
        return peakInd[0],self.sOnData.columns[peakInd[0]],coefs[peakInd[0]]
    
    def getInformedPeaks(self,spectrum,factor,height=50,distance=8,prom=50):
        """Get spectrum peaks and the direction of the linear effect of the factor"""
        coefs = self.getCoefs(factor)
        specPeaks=signal.find_peaks(spectrum,height=height,distance=distance,prominence=prom)
        wvs = self.wavs
        pm = [coefs[i] for i in specPeaks[0]]
        return [wvs[ind] for ind in specPeaks[0]],specPeaks[1]['peak_heights'],pm
    
    def plotWithPeaks(self,spectrum,factor,tightScale=False):
        """Plot the spectrum with labelled peaks for how they correlate with the factor."""
        fig=plt.figure()
        plt.plot(self.wavs,spectrum)
        wvs,heights,pm = self.getInformedPeaks(spectrum, factor)
        pm = np.asarray(pm)
        pos=[]
        neg=[]
        for i in range(len(pm)):
            if pm[i]>0:pos.append(i)
            else: neg.append(i)
        plt.scatter([wvs[i] for i in pos],[heights[i] for i in pos],label='Pos Correlation')
        plt.scatter([wvs[i] for i in neg],[heights[i] for i in neg],label='Neg Correlation')
        if tightScale: plt.ylim((-100,1000))
        plt.title(factor + ' Effect on Spectral Lines')
        plt.legend()
        return fig
    
    def plotSpectrumBySign(self,spectrum,factor):
        """Plot the spectrum with the sign of each intensity as the sign of the linear effects of 'factor.'"""
        fig = plt.figure()
        cs = self.getCoefs(factor)
        csign = cs/np.abs(cs)
        colors=[]
        for sgn in csign:
            if sgn>0: colors.append('red')
            else: colors.append('green') 
        plt.scatter(self.wavs,(spectrum*csign),c=colors,s=1)
        return fig
#%% Main - gives class instance for poking around and testing
def main():
    dp = DataProcessing()
    dp.readIn(r'C:\Users\lridings\Documents\Plasma Diagnostics\References\test_data.csv')
    dp.dropData()
    dp.linearFit()
    return dp
if __name__=='__main__':
    dp=main()